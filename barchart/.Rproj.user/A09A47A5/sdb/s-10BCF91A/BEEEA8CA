{
    "contents" : "library(pracma)\nlibrary(quadrupen)\n\n# returns the infinity-norm of the given vector\ninfNorm <- function(x) {\n  return(norm(x, type=c('I')))\n}\n\n# returns the squared l2-norm of the given vector\nl2NormSq <- function(x) {\n  return(norm(x, type=c('F'))^2)\n}\n\n# returns the l1-norm of the given vector\nl1Norm <- function(x) {\n  return(norm(x, type=c('1')))\n}\n\n# extract the design matrix x and outcome y\ndataset <- read.csv(file=\"~/Documents/testAV/riboflavin_t.csv\", header=TRUE, sep=\",\")\nyinput <- dataset[, 1,drop = FALSE]\ny <- yinput[, 1] # extract values from the data frame\nx <- as.matrix(dataset[, names(dataset) != names(yinput)])\n\n# uncomment 'tic()' and 'toc()' (at the bottom of the file) to time the FOS algorithm\n#tic()\n\n# prepare x and y to be used in calculations and set C\n# x = as.matrix(x)  # this is only necessary in fos.R\n# y = y[, 1]        # this is only necessary in fos.R\nC = 0.75\n\n# useful constants (dimensions of the data)\nn = nrow(x) # number of samples\np = ncol(x) # number of predictors\n\n# used in the duality gap check\ngam = 1\n\n# center and standardize the data (better way to vectorize this?)\nfor (i in 1:p) {\n  x[,i] = (x[,i] - mean(x[,i])) / std(x[,i])\n}\ny = (y - mean(y)) / std(y)\n\n# set up the lambda sequence (rs[1] = rMax > rs[2] > ... > rM > 0)\nM = 100\nrMax = 2 * infNorm(t(x) %*% y)\nrMin = 0.001 * rMax\nrs = logspace(log10(rMax), log10(rMin), M)\n\n# initialization for outer loop\nstatsCont = TRUE\nstatsIt = 1\nbetas = matrix(0, nrow=p, ncol=M) # p by M matrix where columns betas[,j] are associated with rs[j]\nrtilda = rs[M]\n\n# used for debugging\nouterloopcount = 0\n\n# outer loop\nwhile (statsCont && statsIt < M) {\n  \n  # used for debugging\n  outerloopcount = outerloopcount + 1\n  \n  # initialization for inner loop\n  statsIt = statsIt + 1\n  stopCrit = FALSE\n  betaOld = betas[,statsIt - 1]\n  rStatsIt = rs[statsIt]\n  \n  # used for debugging\n  innerloopcount = 0\n  \n  # inner loop\n  while (!stopCrit) {\n    \n    # used for debugging\n    innerloopcount = innerloopcount + 1\n    \n    # values used in duality gap computation\n    beta.t = betas[,statsIt]\n    error = x %*% beta.t - y\n    \n    # compute the dual point, nu.t\n    alternative = rStatsIt / infNorm(2 * t(x) %*% error)\n    s = min(\n          max(alternative,\n              (-1 * t(y) %*% error) / l2NormSq(y - x %*% beta.t)),\n          -1 * alternative)\n    nu.t = -1 * (2 * s / rStatsIt) * error\n    \n    # compute duality gap\n    f.beta = l2NormSq(error) + rStatsIt * l1Norm(beta.t)\n    D.nu = 0.25 * rStatsIt^2 * l2NormSq(nu.t + (2 / rStatsIt) * y) - l2NormSq(y)\n    duality.gap = f.beta + D.nu\n    \n    # uncomment to print debugging information\n    #print(paste0(\"outer loop#: \", outerloopcount, \" inner loop#: \", innerloopcount))\n    #print(paste0(\"non-zero coefficients:      \", sum(betas[,statsIt] != 0)))\n    #print(paste0(\"l1-norm of betaStatsIt:     \", sum(abs(betas[,statsIt]))))\n    #print(paste0(\"statsIt:                    \", statsIt))\n    #print(paste0(\"duality gap at betaStatsIt: \", duality.gap))\n    #print(paste0(\"threshold for duality gap:  \", gam * C^2 * rStatsIt^2 / n))\n    \n    # update the stopping criterion for the inner loop (stopCrit)\n    if (duality.gap <= gam * C^2 * rStatsIt^2 / n) {\n      betas[,statsIt] = betaOld\n      stopCrit = TRUE\n    } else {\n      # uncomment 'tic()' and 'toc()' (a few lines below) to time the lasso optimizer\n      tic()\n      \n      # update beta: extract coefficients from dgCMatrix\n      net = elastic.net(x, y, lambda1=(rStatsIt / 2), lambda2=0, intercept=FALSE, normalize=FALSE,\n                                          beta0=betaOld, control=list(method=\"fista\", max.iter=1))\n      betas[,statsIt] = net@coefficients[1,]\n      #net = optL1(response=y, minlambda1=rStatsIt, maxlambda1=rStatsIt, lambda2=0,\n      #       data=x, model=c(\"linear\"), startbeta=betaOld, maxiter=1, standardize=FALSE)\n      #betas[,statsIt] = net$coefficients[1,]\n      \n      # uncomment 'toc()' and 'tic()' (a few lines above) to time the lasso optimizer\n      toc()\n      \n      # update betaOld\n      betaOld = betas[,statsIt]\n    }\n  }\n  \n  # update the stopping criterion for the outer loop (statsCont)\n  for (k in 1:statsIt) {\n    betak = betas[,k]\n    rk = rs[k] # c/n = 7/8nc\n    statsCont = statsCont && (n * infNorm(betas[,statsIt] - betak) / (rStatsIt + rk) <= C)\n  }\n}\n\nif (!statsCont) {\n  rtilda = rs[statsIt] # minus 1???\n}\n# 21rtilda / 8nc\navfosfit = betas[,statsIt] # minus 1???\n\n# uncomment 'toc()' and 'tic()' (near the top of the file) to time the FOS algorithm\n#toc()\n",
    "created" : 1478630971637.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2689454094",
    "id" : "BEEEA8CA",
    "lastKnownWriteTime" : 1468623186,
    "path" : "~/Documents/testAV/fosPlayground.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "type" : "r_source"
}